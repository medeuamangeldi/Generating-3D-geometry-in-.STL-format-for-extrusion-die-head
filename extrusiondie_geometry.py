# -*- coding: utf-8 -*-
"""ExtrusionDie Geometry.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10iRv4kUoO4pqVPslGJWgiXS6vlGAMHSA
"""

!pip install numpy-stl

import numpy as np
from stl import mesh
import pandas as pd
import math
import matplotlib.pyplot as plt
from scipy.optimize import fsolve

import plotly.graph_objects as go

data = pd.read_excel('/content/drive/MyDrive/Projects/CAD kernel extrusion geometry/dataset.xlsx', index_col= 0)

data = pd.DataFrame.to_numpy(data)

data = np.delete(data, (0,1), axis=0)

x_central = data[:,0]
radius = data[:,1]
y_central = data[:,2]

def equations1(vars):
  x, y = vars
  first_eq = x**2+y**2-d**2
  second_eq = (-2*x1+x)*x+(-2*y1+y)*y-t
  return (first_eq, second_eq)
  
def equations2(vars):
  x, y = vars
  first_eq = x**2+y**2-d1**2
  second_eq = (-2*x1+x)*x+(-2*y1+y)*y-t
  return (first_eq, second_eq)

inner_coordx = []
inner_coordy = []

outer_coordx = []
outer_coordy = []

for i in range(len(data)):
  x1 = x_central[i]
  R1 = radius[i]
  y1 = y_central[i]

  d = np.sqrt(x1**2+y1**2)-R1
  t = R1**2 - x1**2 - y1**2
  d1 = np.sqrt(x1**2+y1**2)+R1
  x, y =  fsolve(equations1, (1, 1))
  x0, y0 = fsolve(equations2, (1, 1))

  if i == 0:
    inner_coordx.append(0)
    inner_coordy.append(y)
    outer_coordx.append(0)
    outer_coordy.append(y0)
  else:
    inner_coordx.append(x)
    inner_coordy.append(y)
    outer_coordx.append(x0)
    outer_coordy.append(y0)

fig = go.Figure()

fig.add_trace(go.Scatter(x = outer_coordx, y = outer_coordy, mode='lines', name='outer curve'))
fig.add_trace(go.Scatter(x = x_central, y = y_central, mode='lines', name='central curve'))
fig.add_trace(go.Scatter(x = inner_coordx, y = inner_coordy, mode='lines', name='inner curve'))

fig.update_layout(title='One quarter of the die head', xaxis_title='x-axis', yaxis_title='y-axis')
fig.show()

points = np.zeros((len(x_central)+1,3))

z_c = 0.01
points[0][2] = z_c

for i in range(len(x_central)):
  points[i+1][0] = inner_coordx[i]
  points[i+1][1] = inner_coordy[i]
  points[i+1][2] = z_c

faces = np.zeros((len(x_central)-1,3))

faces[0][1] = 1
faces[0][2] = 2

for j in range(len(x_central)-2):
  faces[j+1][1] = j + 3
  faces[j+1][2] = j + 2

faces = faces.astype(int)

fig_mesh = go.Figure(data=[go.Scatter3d(
    x=points[:,0],
    y=points[:,1],
    z=points[:,2],
    mode='markers',
    marker=dict(
        size=5,
        color=points[:,2],                # set color to an array/list of desired values
        colorscale='Viridis',   # choose a colorscale
        opacity=0.9
    )
)])
fig_mesh.update_layout(margin=dict(l=0, r=0, b=0, t=0))
fig_mesh.show()

# Create the mesh
die_head = mesh.Mesh(np.zeros(faces.shape[0], dtype=mesh.Mesh.dtype))
for i, f in enumerate(faces):
    for j in range(3):
        die_head.vectors[i][j] = points[f[j],:]

die_head.save('die_head1Q.stl')

